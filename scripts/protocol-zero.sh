#!/usr/bin/env bash
#===============================================================================
# protocol-zero.sh — Protocol Zero Enforcement Scanner
#===============================================================================
#
# Scans codebase and commit metadata for forbidden AI attribution markers
# as defined in CLAUDE.md Section 1 (Protocol Zero governance).
#
# AUTHORITY: CLAUDE.md §1 — No-AI Attribution (HIGHEST PRIORITY)
#
# EXIT CODES:
#   0   Clean — no violations detected
#   1   Violation — attribution markers found
#   2   Usage error — invalid arguments or missing dependencies
#   3   Environment error — required tools unavailable
#
# USAGE:
#   ./scripts/protocol-zero.sh                         # Full codebase scan
#   ./scripts/protocol-zero.sh --dir <path>            # Scan specific directory
#   ./scripts/protocol-zero.sh --commit-msg "message"  # Validate commit message
#   ./scripts/protocol-zero.sh --commit-msg-file <path># Validate from file
#   ./scripts/protocol-zero.sh --dry-run               # Preview without scanning
#   ./scripts/protocol-zero.sh --verbose               # Extended diagnostics
#   ./scripts/protocol-zero.sh --help                  # Display usage
#
# INTEGRATION:
#   Pre-commit hook:  ./scripts/protocol-zero.sh --commit-msg-file "$1"
#
#===============================================================================

set -euo pipefail

#===============================================================================
# CONFIGURATION: Script metadata
#===============================================================================

readonly SCRIPT_NAME="protocol-zero"
readonly SCRIPT_VERSION="1.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_DIR
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
readonly PROJECT_ROOT

#===============================================================================
# CONFIGURATION: ANSI color codes
#===============================================================================
# Uses ANSI-C quoting ($'...') so escape bytes are stored directly in
# variables, allowing safe use as %s arguments in printf (SC2059-clean).
# Respects NO_COLOR environment variable (https://no-color.org/).
# CLI --no-color flag handled via pre-scan before initialization.
#===============================================================================

for _arg in "$@"; do
    [[ "$_arg" == "--no-color" ]] && NO_COLOR=1
done
unset _arg

if [[ -t 1 ]] && [[ "${NO_COLOR:-}" != "1" ]]; then
    readonly RED=$'\033[31m'
    readonly GREEN=$'\033[32m'
    readonly YELLOW=$'\033[33m'
    readonly CYAN=$'\033[36m'
    readonly BOLD=$'\033[1m'
    readonly DIM=$'\033[2m'
    readonly NC=$'\033[0m'
else
    readonly RED=''
    readonly GREEN=''
    readonly YELLOW=''
    readonly CYAN=''
    readonly BOLD=''
    readonly DIM=''
    readonly NC=''
fi

#===============================================================================
# CONFIGURATION: Prohibited patterns
#===============================================================================
# AI attribution markers violating Protocol Zero (CLAUDE.md §1).
# Case-insensitive matching.
# Modification requires governance review per CLAUDE.md §2.
#===============================================================================

readonly -a PROHIBITED_PATTERNS=(
    # === Direct AI Attribution (CLAUDE.md §1) ===
    "generated by claude"
    "generated by ai"
    "generated by copilot"
    "generated by gpt"
    "generated by chatgpt"
    "generated by llm"
    "generated by gemini"
    "generated by anthropic"
    "generated by openai"

    # === AI Assistance Indicators ===
    "ai.assisted"
    "ai-assisted"
    "ai assisted"
    "ai generated"
    "ai-generated"
    "created with ai"
    "created by ai"
    "written by ai"
    "written by claude"
    "written by gpt"
    "written by copilot"
    "llm-optimized"

    # === Git Co-Author Attribution ===
    "co-authored-by:.*claude"
    "co-authored-by:.*copilot"
    "co-authored-by:.*\\bai\\b"
    "co-authored-by:.*anthropic"
    "co-authored-by:.*openai"
    "co-authored-by:.*gemini"
    "co-authored-by:.*noreply@anthropic"

    # === Conversational Filler (CLAUDE.md §1) ===
    "i hope this helps"
    "as requested"
    "here is the code"
    "as an ai"
    "as a language model"
    "i'm an ai"
    "i am an ai"
    "based on the design doc"
    "i have updated"

    # === Apologetic Preambles ===
    "let me help you"
    "i'll help you"
    "i can help"
    "happy to help"
    "certainly!"
    "of course!"
    "absolutely!"
)

#===============================================================================
# CONFIGURATION: Directory exclusions
#===============================================================================
# Excluded from scanning: build artifacts, Xcode caches, IDE metadata,
# and dependency directories where attribution markers are irrelevant.
#===============================================================================

readonly -a EXCLUDE_DIRS=(
    # === Version Control ===
    ".git"

    # === Xcode Build Artifacts ===
    "DerivedData"
    ".build"
    "xcuserdata"
    "Build"

    # === Swift Package Manager ===
    ".swiftpm"

    # === Python Caches (audit tooling) ===
    "__pycache__"
    ".mypy_cache"

    # === IDE & Editor ===
    ".idea"
    ".vscode"

    # === Xcode Asset Catalogs (Xcode-managed JSON) ===
    "*.xcassets"
    "*.xcodeproj"
    "*.xcworkspace"
    "*.spriteatlas"
)

#===============================================================================
# CONFIGURATION: Path pattern exclusions
#===============================================================================
# Partial path patterns excluded from scanning. These are governance,
# planning, or skill paths that legitimately reference prohibited phrases.
#===============================================================================

readonly -a EXCLUDE_PATH_PATTERNS=(
    ".claude/skills/"
    ".claude/context/"
    "docs/"
)

#===============================================================================
# CONFIGURATION: File exclusions
#===============================================================================
# Specific filenames excluded. Governance files necessarily contain
# prohibited patterns as rule definitions or enforcement logic.
#===============================================================================

readonly -a EXCLUDE_FILES=(
    "CLAUDE.md"
    "Design-Doc.md"
    "protocol-zero.sh"
    "audit.py"
    "SKILL.md"
    "remediation.md"
    "AGENT_CONTEXT_SYSTEM.md"
    ".gitignore"
    ".markdownlint.json"
    ".markdownlintignore"
)

#===============================================================================
# CONFIGURATION: Binary extensions
#===============================================================================
# Non-textual file extensions. Scanning produces false positives and
# wastes time on binary content.
#===============================================================================

readonly -a BINARY_EXTENSIONS=(
    # === Images ===
    "png" "jpg" "jpeg" "gif" "ico" "svg" "webp" "bmp" "tiff" "heic" "heif"
    # === Fonts ===
    "woff" "woff2" "ttf" "eot" "otf"
    # === Documents ===
    "pdf" "doc" "docx"
    # === Archives ===
    "zip" "tar" "gz" "bz2" "7z" "xz"
    # === Audio ===
    "mp3" "mp4" "wav" "m4a" "aac" "flac" "caf" "aiff"
    # === Video ===
    "avi" "mov" "mkv"
    # === Xcode Compiled Assets ===
    "car" "nib" "storyboardc" "momd"
    # === SpriteKit Scene Archives ===
    "sks" "scn"
    # === Compiled Binaries ===
    "o" "a" "dylib" "so" "exe"
    # === Lock / Resolution Files ===
    "lock" "lockb" "resolved"
)

#===============================================================================
# STATE: Runtime variables
#===============================================================================

VIOLATIONS_FOUND=0
declare -a VIOLATION_DETAILS=()
DRY_RUN=0
VERBOSE=0

#===============================================================================
# FUNCTION: cleanup
#===============================================================================

cleanup() {
    local exit_code=$?
    exit "${exit_code}"
}

#===============================================================================
# FUNCTION: trap_handler
#===============================================================================

trap_handler() {
    local signal="$1"
    log_warning "Received ${signal}, terminating gracefully..."
    exit 130
}

#===============================================================================
# TRAP REGISTRATION
#===============================================================================

trap cleanup EXIT
trap 'trap_handler SIGINT' INT
trap 'trap_handler SIGTERM' TERM

#===============================================================================
# FUNCTION: log_info
#===============================================================================

log_info() {
    printf '  %s%s%s\n' "${DIM}" "$1" "${NC}"
}

#===============================================================================
# FUNCTION: log_verbose
#===============================================================================

log_verbose() {
    if [[ "${VERBOSE}" -eq 1 ]]; then
        printf '  %s· %s%s\n' "${DIM}" "$1" "${NC}"
    fi
}

#===============================================================================
# FUNCTION: log_warning
#===============================================================================

log_warning() {
    printf '  %s⚠%s  %s\n' "${YELLOW}" "${NC}" "$1" >&2
}

#===============================================================================
# FUNCTION: log_error
#===============================================================================

log_error() {
    printf '  %s✗%s  %s\n' "${RED}" "${NC}" "$1" >&2
}

#===============================================================================
# FUNCTION: log_pass
#===============================================================================

log_pass() {
    printf '  %s✓%s  %s\n' "${GREEN}" "${NC}" "$1"
}

#===============================================================================
# FUNCTION: log_fail
#===============================================================================

log_fail() {
    printf '  %s✗%s  %s\n' "${RED}" "${NC}" "$1"
}

#===============================================================================
# FUNCTION: print_header
#===============================================================================

print_header() {
    local title="$1"
    printf '\n'
    printf '  %s%sprotocol-zero%s %sv%s%s\n' \
        "${CYAN}" "${BOLD}" "${NC}" "${DIM}" "${SCRIPT_VERSION}" "${NC}"
    printf '  %s▶%s  %s%s%s\n' "${CYAN}" "${NC}" "${BOLD}" "${title}" "${NC}"
    printf '\n'
}

#===============================================================================
# FUNCTION: print_detail
#===============================================================================

print_detail() {
    local label="$1"
    local value="$2"
    printf '    %s%-14s%s%s\n' "${DIM}" "${label}" "${NC}" "${value}"
}

#===============================================================================
# FUNCTION: print_violation
#===============================================================================

print_violation() {
    local file="$1"
    local line_num="$2"
    local content="$3"
    local pattern="$4"

    printf '      %s%-5s%s  %s%s%s  %s%.55s%s\n' \
        "${DIM}" "${line_num}" "${NC}" \
        "${YELLOW}" "${pattern}" "${NC}" \
        "${DIM}" "${content}" "${NC}"
}

#===============================================================================
# FUNCTION: check_dependencies
#===============================================================================

check_dependencies() {
    local -a required_tools=("grep" "find" "wc" "basename" "dirname")
    local missing=0

    for tool in "${required_tools[@]}"; do
        if ! command -v "${tool}" &>/dev/null; then
            log_error "Required tool not found: ${tool}"
            missing=1
        fi
    done

    if [[ "${missing}" -eq 1 ]]; then
        log_error "Install missing dependencies and retry."
        return 3
    fi

    log_verbose "All dependencies verified: ${required_tools[*]}"
    return 0
}

#===============================================================================
# FUNCTION: build_exclude_args
#===============================================================================

build_exclude_args() {
    local args=""

    for dir in "${EXCLUDE_DIRS[@]}"; do
        args="${args} --exclude-dir=${dir}"
    done

    for ext in "${BINARY_EXTENSIONS[@]}"; do
        args="${args} --exclude=*.${ext}"
    done

    for file in "${EXCLUDE_FILES[@]}"; do
        args="${args} --exclude=${file}"
    done

    printf "%s" "${args}"
}

#===============================================================================
# FUNCTION: should_exclude_file
#===============================================================================

should_exclude_file() {
    local filepath="$1"
    local filename
    filename="$(basename "${filepath}")"

    for exclude in "${EXCLUDE_FILES[@]}"; do
        if [[ "${filename}" == "${exclude}" ]]; then
            log_verbose "Excluding file (name match): ${filepath}"
            return 0
        fi
    done

    for path_pattern in "${EXCLUDE_PATH_PATTERNS[@]}"; do
        if [[ "${filepath}" == *"${path_pattern}"* ]]; then
            log_verbose "Excluding file (path match): ${filepath}"
            return 0
        fi
    done

    return 1
}

#===============================================================================
# FUNCTION: scan_text
#===============================================================================

scan_text() {
    local text="$1"
    local source="${2:-stdin}"
    local found=1

    for pattern in "${PROHIBITED_PATTERNS[@]}"; do
        if echo "${text}" | grep -iEq "${pattern}"; then
            found=0
            VIOLATIONS_FOUND=1
            local match
            match="$(echo "${text}" | grep -iE "${pattern}" | head -1)"
            VIOLATION_DETAILS+=("Source: ${source} | Pattern: ${pattern} | Match: ${match:0:60}")
        fi
    done

    return "${found}"
}

#===============================================================================
# FUNCTION: scan_commit_message
#===============================================================================

scan_commit_message() {
    local message="$1"

    print_header "Commit Message Validation"

    if [[ "${DRY_RUN}" -eq 1 ]]; then
        log_info "Dry run — would scan commit message (${#message} characters)"
        printf '\n'
        return 0
    fi

    if scan_text "${message}" "commit-message"; then
        log_fail "Protocol Zero violation in commit message"
        printf '\n'
        for detail in "${VIOLATION_DETAILS[@]}"; do
            printf '    %s%s%s\n' "${DIM}" "${detail}" "${NC}"
        done
        printf '\n'
        printf '  %s⚠%s  %sRemove attribution markers before committing.%s\n\n' \
            "${YELLOW}" "${NC}" "${BOLD}" "${NC}"
        return 1
    else
        log_pass "Commit message compliant with Protocol Zero"
        printf '\n'
        return 0
    fi
}

#===============================================================================
# FUNCTION: scan_codebase
#===============================================================================

scan_codebase() {
    local root_dir="${1:-.}"

    if [[ ! -d "${root_dir}" ]]; then
        log_error "Directory not found: ${root_dir}"
        return 2
    fi

    root_dir="$(cd "${root_dir}" && pwd)"

    print_header "Codebase Attribution Scan"

    print_detail "Directory" "${root_dir}"
    print_detail "Patterns" "${#PROHIBITED_PATTERNS[@]}"
    print_detail "Excluding" "${#EXCLUDE_DIRS[@]} directories, ${#EXCLUDE_FILES[@]} files"
    log_verbose "Excluded directories: ${EXCLUDE_DIRS[*]}"
    log_verbose "Excluded files: ${EXCLUDE_FILES[*]}"

    if [[ "${DRY_RUN}" -eq 1 ]]; then
        printf '\n'
        log_info "Dry run — would scan ${root_dir}, no changes made"
        printf '\n'
        return 0
    fi

    local exclude_args
    exclude_args="$(build_exclude_args)"

    local -a violations_in_files=()

    for pattern in "${PROHIBITED_PATTERNS[@]}"; do
        log_verbose "Scanning for pattern: ${pattern}"

        local grep_cmd="grep -rilE ${exclude_args} \"${pattern}\" \"${root_dir}\" 2>/dev/null || true"
        local matches
        matches="$(eval "${grep_cmd}")"

        if [[ -n "${matches}" ]]; then
            while IFS= read -r filepath; do
                if should_exclude_file "${filepath}"; then
                    continue
                fi

                local line_matches
                line_matches="$(grep -inE "${pattern}" "${filepath}" 2>/dev/null || true)"

                if [[ -n "${line_matches}" ]]; then
                    VIOLATIONS_FOUND=1
                    while IFS= read -r line_match; do
                        local line_num
                        line_num="$(echo "${line_match}" | cut -d: -f1)"
                        local content
                        content="$(echo "${line_match}" | cut -d: -f2-)"
                        violations_in_files+=("${filepath}:${line_num}|${pattern}|${content}")
                    done <<< "${line_matches}"
                fi
            done <<< "${matches}"
        fi
    done

    local files_scanned
    files_scanned="$(find "${root_dir}" -type f \
        ! -path "*/.git/*" \
        ! -path "*/DerivedData/*" \
        ! -path "*/.build/*" \
        ! -path "*/xcuserdata/*" \
        ! -path "*/__pycache__/*" \
        ! -path "*/.mypy_cache/*" \
        ! -path "*/.swiftpm/*" \
        ! -name "*.png" \
        ! -name "*.jpg" \
        ! -name "*.heic" \
        ! -name "*.m4a" \
        ! -name "*.pdf" \
        ! -name "*.lock" \
        ! -name "*.car" \
        ! -name "*.o" \
        ! -name "*.dylib" \
        2>/dev/null | wc -l | tr -d ' ')"

    print_detail "Scanned" "~${files_scanned} files"
    printf '\n'

    if [[ "${VIOLATIONS_FOUND}" -eq 1 ]]; then
        log_fail "Protocol Zero violation detected"

        local prev_file=""
        for violation in "${violations_in_files[@]}"; do
            local filepath
            filepath="$(echo "${violation}" | cut -d'|' -f1)"
            local file_part
            file_part="$(echo "${filepath}" | cut -d: -f1)"
            local line_num
            line_num="$(echo "${filepath}" | cut -d: -f2)"
            local pattern
            pattern="$(echo "${violation}" | cut -d'|' -f2)"
            local content
            content="$(echo "${violation}" | cut -d'|' -f3-)"

            if [[ "${file_part}" != "${prev_file}" ]]; then
                printf '\n    %s%s%s\n' "${BOLD}" "${file_part}" "${NC}"
                prev_file="${file_part}"
            fi
            print_violation "${file_part}" "${line_num}" "${content}" "${pattern}"
        done

        printf '\n'
        printf '  %s⚠%s  %sRemove attribution markers before committing.%s\n' \
            "${YELLOW}" "${NC}" "${BOLD}" "${NC}"
        printf '    %sCLAUDE.md §1 — Protocol Zero%s\n\n' "${DIM}" "${NC}"
        return 1
    else
        log_pass "No attribution artifacts detected"
        printf '    %s%s files · %s patterns%s\n\n' \
            "${DIM}" "${files_scanned}" "${#PROHIBITED_PATTERNS[@]}" "${NC}"
        return 0
    fi
}

#===============================================================================
# FUNCTION: print_usage
#===============================================================================

print_usage() {
    cat << EOF

  ${CYAN}${BOLD}protocol-zero${NC} ${DIM}v${SCRIPT_VERSION}${NC}
  ${DIM}Protocol Zero Enforcement Scanner${NC}

  Scans codebase and commit metadata for forbidden
  AI attribution markers per CLAUDE.md §1.

  ${BOLD}USAGE${NC}
    ${SCRIPT_NAME} [OPTIONS]

  ${BOLD}OPTIONS${NC}
    --help, -h               Show this help message
    --version, -v            Show version
    --dir <path>             Scan specific directory ${DIM}(default: project root)${NC}
    --commit-msg <message>   Validate a commit message
    --commit-msg-file <path> Validate from file ${DIM}(pre-commit hook)${NC}
    --dry-run                Preview without scanning
    --verbose                Extended diagnostics
    --no-color               Disable colored output

  ${BOLD}EXIT CODES${NC}
    ${GREEN}0${NC}   Clean — no violations
    ${RED}1${NC}   Violation — markers found
    ${YELLOW}2${NC}   Usage error
    ${YELLOW}3${NC}   Environment error

  ${BOLD}EXAMPLES${NC}
    ${DIM}# Scan entire repository${NC}
    ${SCRIPT_NAME}

    ${DIM}# Scan Swift source tree${NC}
    ${SCRIPT_NAME} --dir ./StarlightSync

    ${DIM}# Validate commit message${NC}
    ${SCRIPT_NAME} --commit-msg "feat(ch2): add obstacle spawning"

    ${DIM}# Pre-commit hook${NC}
    ${SCRIPT_NAME} --commit-msg-file .git/COMMIT_EDITMSG

  ${BOLD}INTEGRATION${NC}
    Pre-commit hook ${DIM}(.git/hooks/commit-msg)${NC}:
      #!/bin/sh
      ./scripts/protocol-zero.sh --commit-msg-file "\$1"

  ${DIM}Governance: CLAUDE.md §1 — Protocol Zero${NC}

EOF
}

#===============================================================================
# FUNCTION: print_version
#===============================================================================

print_version() {
    printf '%s v%s\n' "${SCRIPT_NAME}" "${SCRIPT_VERSION}"
}

#===============================================================================
# FUNCTION: main
#===============================================================================

main() {
    local mode="codebase"
    local commit_msg=""
    local commit_msg_file=""
    local scan_dir="${PROJECT_ROOT}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --commit-msg)
                if [[ -z "${2:-}" ]]; then
                    log_error "Missing argument for --commit-msg"
                    return 2
                fi
                mode="commit"
                commit_msg="$2"
                shift 2
                ;;
            --commit-msg-file)
                if [[ -z "${2:-}" ]]; then
                    log_error "Missing argument for --commit-msg-file"
                    return 2
                fi
                mode="commit-file"
                commit_msg_file="$2"
                shift 2
                ;;
            --dir)
                if [[ -z "${2:-}" ]]; then
                    log_error "Missing argument for --dir"
                    return 2
                fi
                scan_dir="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=1
                shift
                ;;
            --verbose)
                VERBOSE=1
                shift
                ;;
            --no-color)
                shift
                ;;
            --help|-h)
                print_usage
                return 0
                ;;
            --version|-v)
                print_version
                return 0
                ;;
            -*)
                log_warning "Unknown option: $1"
                shift
                ;;
            *)
                log_warning "Unexpected argument: $1"
                shift
                ;;
        esac
    done

    check_dependencies || return $?

    log_verbose "Mode: ${mode}"
    log_verbose "Dry run: ${DRY_RUN}"
    log_verbose "Project root: ${PROJECT_ROOT}"

    case "${mode}" in
        commit)
            scan_commit_message "${commit_msg}"
            ;;
        commit-file)
            if [[ ! -f "${commit_msg_file}" ]]; then
                log_error "Commit message file not found: ${commit_msg_file}"
                return 2
            fi
            local msg
            msg="$(cat "${commit_msg_file}")"
            scan_commit_message "${msg}"
            ;;
        codebase)
            scan_codebase "${scan_dir}"
            ;;
        *)
            log_error "Unknown mode: ${mode}"
            return 2
            ;;
    esac
}

#===============================================================================
# EXECUTION
#===============================================================================

main "$@"
